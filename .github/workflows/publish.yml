name: Publish to PyPI

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 2.0.4)'
        required: true
        type: string

permissions:
  contents: read
  id-token: write
  actions: write

jobs:
  ensure-tests-running:
    name: Ensure Build Tests Are Running
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.find-or-trigger.outputs.run_id }}
    
    steps:
      - name: Find existing or trigger new build
        id: find-or-trigger
        uses: actions/github-script@v7
        with:
          script: |
            const workflow_id = 'cross-platform-build-verification.yml';
            const ref = context.eventName === 'release' 
              ? context.payload.release.tag_name 
              : context.ref;
            
            console.log(`üîç Looking for builds for ref: ${ref} (SHA: ${context.sha})`);
            
            // 1. Get ALL recent runs (don't filter by status yet)
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflow_id,
              per_page: 20
            });
            
            // 2. Filter client-side for ANY active status (Queued OR In Progress)
            const activeStatuses = ['queued', 'in_progress', 'waiting', 'requested', 'pending'];
            
            let targetRun = runs.data.workflow_runs.find(run => 
              (run.head_sha === context.sha || run.head_branch === ref) &&
              activeStatuses.includes(run.status)
            );
            
            if (targetRun) {
              console.log(`‚úÖ Found existing active build: ${targetRun.id}`);
              console.log(`   Status: ${targetRun.status}`);
              core.setOutput('run_id', targetRun.id);
              return;
            }
            
            // 3. If release event, wait loop (checking for Queued as well)
            if (context.eventName === 'release') {
              console.log('üì¶ Release event - waiting for auto-triggered build to appear...');
              
              for (let i = 0; i < 12; i++) { // Wait up to 1 minute
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                const refreshRuns = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow_id,
                  per_page: 20
                });
                
                targetRun = refreshRuns.data.workflow_runs.find(run => 
                  run.head_sha === context.sha &&
                  activeStatuses.includes(run.status)
                );
                
                if (targetRun) {
                  console.log(`‚úÖ Found auto-triggered build: ${targetRun.id} (${targetRun.status})`);
                  core.setOutput('run_id', targetRun.id);
                  return;
                }
              }
              throw new Error('‚ùå Release should have auto-triggered build, but none found');
            }
            
            // 4. Manual trigger - create new build
            console.log('üîß Manual workflow_dispatch - triggering new build...');
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflow_id,
              ref: ref
            });
            
            console.log('Waiting for new build to appear...');
            
            // Wait for the triggered build to show up
            for (let i = 0; i < 24; i++) { // Wait up to 2 minutes
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              const newRuns = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow_id,
                per_page: 10
              });
              
              // We look for the one we just triggered (latest non-completed)
              const latestRun = newRuns.data.workflow_runs.find(run => 
                activeStatuses.includes(run.status)
              );
              
              if (latestRun) {
                console.log(`‚úÖ New build started: ${latestRun.id} (${latestRun.status})`);
                core.setOutput('run_id', latestRun.id);
                return;
              }
            }
            
            throw new Error('‚ùå Failed to find triggered build');
            
  wait-for-tests:
    name: Wait for Build Completion
    needs: ensure-tests-running
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for build workflow (INFINITE - NO TIMEOUT)
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = '${{ needs.ensure-tests-running.outputs.run_id }}';
            const intervalMs = 30000; // Check every 30 seconds
            
            console.log(`üîç Monitoring build run ID: ${run_id}`);
            console.log(`‚è∞ Will wait INDEFINITELY until build completes (no timeout)`);
            
            let iteration = 0;
            
            while (true) {
              iteration++;
              
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: run_id
              });
              
              const elapsed = Math.floor((iteration * intervalMs) / 60000);
              console.log(`[${elapsed}m] Status: ${run.data.status} | Conclusion: ${run.data.conclusion || 'N/A'}`);
              
              if (run.data.status === 'completed') {
                if (run.data.conclusion === 'success') {
                  console.log('‚úÖ All build tests passed!');
                  return;
                } else {
                  throw new Error(`‚ùå Build failed with conclusion: ${run.data.conclusion}`);
                }
              }
              
              // Still running - keep waiting
              if (run.data.status === 'queued') {
                console.log('   ‚è≥ Build is queued, waiting for runner...');
              } else if (run.data.status === 'in_progress') {
                console.log('   üèÉ Build is running...');
              }
              
              await new Promise(resolve => setTimeout(resolve, intervalMs));
            }

  deploy:
    needs: wait-for-tests
    runs-on: ubuntu-latest
    environment: pypi
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.release.tag_name || github.ref }}
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine tomli
        
    - name: Verify package version
      run: |
        PACKAGE_VERSION=$(python -c "import tomli; print(tomli.load(open('pyproject.toml', 'rb'))['project']['version'])")
        
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          EXPECTED_VERSION="${{ inputs.version }}"
        else
          TAG_VERSION="${{ github.ref_name }}"
          EXPECTED_VERSION=${TAG_VERSION#v}
        fi
        
        echo "Package version: $PACKAGE_VERSION"
        echo "Expected version: $EXPECTED_VERSION"
        
        if [ "$PACKAGE_VERSION" != "$EXPECTED_VERSION" ]; then
          echo "‚ùå Version mismatch!"
          exit 1
        fi
        
    - name: Clean and build
      run: |
        rm -rf dist/ build/ *.egg-info/
        python -m build
        
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_API_TOKEN }}
    
    - name: Success
      run: echo "üéâ Published!"
