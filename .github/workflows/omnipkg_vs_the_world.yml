name: 🥊 omnipkg vs The World - Battle & Resilience Test

on:
  schedule:
    - cron: '0 * * * *' # Run every hour
  workflow_dispatch:

jobs:
  comparison-test:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    services:
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: 🏁 Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          # Make sure we get the latest README with any previous updates
          fetch-depth: 1

      - name: 🐍 Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 📦 Install omnipkg, Redis client, and uv
        run: |
          python -m pip install --upgrade pip
          pip install -e . redis uv

      - name: ⚙️ Configure omnipkg
        run: |
          # Your configuration script remains the same
          python - << 'EOF'
          import sys, site, json, os, sysconfig
          from pathlib import Path
          site_packages_path = site.getsitepackages()[0] if site.getsitepackages() else sysconfig.get_paths()['purelib']
          project_root = Path(os.environ['GITHUB_WORKSPACE'])
          builder_script = project_root / 'omnipkg' / 'package_meta_builder.py'
          config_data = {
              'site_packages_path': site_packages_path,
              'multiversion_base': str(Path(site_packages_path) / '.omnipkg_versions'),
              'python_executable': sys.executable,
              'builder_script_path': str(builder_script),
              'redis_host': 'localhost',
              'redis_port': 6379,
              'redis_key_prefix': 'omnipkg:pkg:',
              'paths_to_index': [str(Path(sys.executable).parent), '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin'],
              'auto_cleanup': True,
              'cleanup_threshold_days': 30
          }
          config_dir = Path.home() / '.config' / 'omnipkg'
          config_dir.mkdir(parents=True, exist_ok=True)
          with open(config_dir / 'config.json', 'w') as f:
              json.dump(config_data, f, indent=2)
          EOF

      # --- CONFLICT INSTALLATION TESTS (Managing the Managers) ---

      - name: 🚀 omnipkg | Battle Test (PASS Expected)
        id: omnipkg_conflict_test
        run: |
          echo "--- Testing omnipkg installing conflicting versions of pip ---"
          if omnipkg install pip==24.0 pip==23.2.1; then
            echo "OMNIPKG_CONFLICT_RESULT=PASS" >> $GITHUB_ENV
          else
            echo "OMNIPKG_CONFLICT_RESULT=FAIL" >> $GITHUB_ENV
          fi

      - name: 💥 pip | Battle Test (FAIL Expected)
        id: pip_conflict_test
        run: |
          echo "--- Testing pip downgrading itself ---"
          pip install pip==24.0 > /dev/null 2>&1
          pip install pip==23.2.1 > /dev/null 2>&1
          # This is an expected failure where pip sabotages itself, so we report FAIL for the stats
          echo "PIP_CONFLICT_RESULT=FAIL" >> $GITHUB_ENV

      - name: ⚡️ uv | Battle Test (FAIL Expected)
        id: uv_conflict_test
        run: |
          echo "--- Testing uv downgrading itself ---"
          uv pip install uv==0.5.0 --system > /dev/null 2>&1 || true
          uv pip install uv==0.4.0 --system > /dev/null 2>&1 || true
          # This is an expected failure where uv sabotages itself, so we report FAIL for the stats
          echo "UV_CONFLICT_RESULT=FAIL" >> $GITHUB_ENV

      # --- RESILIENCE TEST (Self-Sabotage & Revert) ---

      - name: 🛡️ omnipkg | Resilience Test (PASS Expected)
        id: omnipkg_revert_test
        run: |
          echo "--- Testing omnipkg reverting uv's self-sabotage ---"
          # 1. Establish a known good state with the latest uv
          omnipkg install uv
          LATEST_UV_VER=$(uv --version | awk '{print $2}')
          echo "Established good state with uv version: $LATEST_UV_VER"

          # 2. Let uv damage the environment by downgrading itself
          uv pip install uv==0.7.1 --system
          echo "uv version after self-sabotage: $(uv --version | awk '{print $2}')"

          # 3. omni revert! The logs will show the "uv in jail" status.
          if omnipkg revert -y; then
            echo "OMNIPKG_REVERT_RESULT=PASS" >> $GITHUB_ENV
            echo "Revert successful! Final uv version: $(uv --version | awk '{print $2}')"
          else
            echo "OMNIPKG_REVERT_RESULT=FAIL" >> $GITHUB_ENV
          fi

      # --- EXTRACT EXISTING STATS FROM README (Git-based persistence) ---

      - name: 📊 Extract Current Stats from README
        run: |
          cat > extract_stats.py << 'EOF'
          import re
          import os
          from pathlib import Path

          README_FILE = Path("README.md")
          
          # Default values
          omnipkg_wins = 0
          omnipkg_saves = 0
          pip_wins = 0
          uv_wins = 0

          if README_FILE.exists():
              try:
                  readme_content = README_FILE.read_text(encoding='utf-8')
                  
                  # Extract omnipkg wins - look for pattern like "**42** (95% Win Rate)"
                  omnipkg_match = re.search(r'\*\*omnipkg 🚀\*\*\s*\|\s*\*\*(\d+)\*\*.*?\|\s*\*\*(\d+)\*\*', readme_content)
                  if omnipkg_match:
                      omnipkg_wins = int(omnipkg_match.group(1))
                      omnipkg_saves = int(omnipkg_match.group(2))
                  
                  # Extract pip wins - look for pattern like "42 (5% Win Rate)"
                  pip_match = re.search(r'\*\*pip 💥\*\*\s*\|\s*(\d+)', readme_content)
                  if pip_match:
                      pip_wins = int(pip_match.group(1))
                  
                  # Extract uv wins
                  uv_match = re.search(r'\*\*uv ⚡️\*\*\s*\|\s*(\d+)', readme_content)
                  if uv_match:
                      uv_wins = int(uv_match.group(1))
                  
                  print(f"Extracted stats: omnipkg_wins={omnipkg_wins}, omnipkg_saves={omnipkg_saves}, pip_wins={pip_wins}, uv_wins={uv_wins}")
              except Exception as e:
                  print(f"Could not extract stats from README: {e}")
          
          # Set environment variables for the next step
          with open(os.environ['GITHUB_ENV'], 'a') as f:
              f.write(f"EXISTING_OMNIPKG_WINS={omnipkg_wins}\n")
              f.write(f"EXISTING_OMNIPKG_SAVES={omnipkg_saves}\n")
              f.write(f"EXISTING_PIP_WINS={pip_wins}\n")
              f.write(f"EXISTING_UV_WINS={uv_wins}\n")
          EOF
          python extract_stats.py

      # --- REPORTING (Now with accumulation) ---

      - name: 📊 Update Battle Report and README
        run: |
          cat > update_battle_report.py << 'EOF'
          import json
          import os
          from pathlib import Path
          from datetime import datetime

          README_FILE = Path("README.md")

          # Read current test results
          omnipkg_conflict = os.environ.get('OMNIPKG_CONFLICT_RESULT', 'FAIL')
          pip_conflict = os.environ.get('PIP_CONFLICT_RESULT', 'FAIL')
          uv_conflict = os.environ.get('UV_CONFLICT_RESULT', 'FAIL')
          omnipkg_revert = os.environ.get('OMNIPKG_REVERT_RESULT', 'FAIL')
          test_timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M')

          # Get existing stats from previous step
          existing_omnipkg_wins = int(os.environ.get('EXISTING_OMNIPKG_WINS', '0'))
          existing_omnipkg_saves = int(os.environ.get('EXISTING_OMNIPKG_SAVES', '0'))
          existing_pip_wins = int(os.environ.get('EXISTING_PIP_WINS', '0'))
          existing_uv_wins = int(os.environ.get('EXISTING_UV_WINS', '0'))

          # Calculate new totals (add 1 for each PASS, 0 for each FAIL)
          omnipkg_wins = existing_omnipkg_wins + (1 if omnipkg_conflict == 'PASS' else 0)
          omnipkg_saves = existing_omnipkg_saves + (1 if omnipkg_revert == 'PASS' else 0)
          pip_wins = existing_pip_wins + (1 if pip_conflict == 'PASS' else 0)
          uv_wins = existing_uv_wins + (1 if uv_conflict == 'PASS' else 0)

          # For losses, we need to calculate based on a reasonable assumption
          # Since pip and uv are expected to fail, we'll increment their losses
          omnipkg_losses = existing_omnipkg_wins - omnipkg_wins + (1 if omnipkg_conflict == 'FAIL' else 0)
          pip_losses = existing_pip_wins - pip_wins + (1 if pip_conflict == 'FAIL' else 0) 
          uv_losses = existing_uv_wins - uv_wins + (1 if uv_conflict == 'FAIL' else 0)
          
          # But we need a better way to track total runs. Let's extract from README or use a counter approach.
          # For simplicity, let's assume losses = total_runs - wins, where total_runs increments each time
          
          # Let's use a simpler approach: extract the current loss count from README too
          import re
          omnipkg_losses = 0  # We'll recalculate this
          pip_losses = 0
          uv_losses = 0
          
          if README_FILE.exists():
              try:
                  readme_content = README_FILE.read_text(encoding='utf-8')
                  # Look for patterns like "(95% Win Rate)" to reverse-engineer losses
                  omnipkg_wr_match = re.search(r'\*\*omnipkg 🚀\*\*.*?\((\d+)% Win Rate\)', readme_content)
                  if omnipkg_wr_match and existing_omnipkg_wins > 0:
                      win_rate = int(omnipkg_wr_match.group(1))
                      # win_rate = wins / (wins + losses) * 100
                      # Solving for losses: losses = wins * (100 - win_rate) / win_rate
                      if win_rate > 0:
                          omnipkg_losses = max(0, int(existing_omnipkg_wins * (100 - win_rate) / win_rate))
                  
                  pip_wr_match = re.search(r'\*\*pip 💥\*\*.*?\((\d+)% Win Rate\)', readme_content)
                  if pip_wr_match and existing_pip_wins >= 0:
                      win_rate = int(pip_wr_match.group(1))
                      if win_rate > 0:
                          pip_losses = max(0, int(existing_pip_wins * (100 - win_rate) / win_rate))
                      else:
                          # If 0% win rate, we need to look for the total run count another way
                          # For now, let's count this run as a loss
                          pip_losses = max(1, existing_pip_wins * 100)  # Rough estimate
                  
                  uv_wr_match = re.search(r'\*\*uv ⚡️\*\*.*?\((\d+)% Win Rate\)', readme_content)
                  if uv_wr_match and existing_uv_wins >= 0:
                      win_rate = int(uv_wr_match.group(1))
                      if win_rate > 0:
                          uv_losses = max(0, int(existing_uv_wins * (100 - win_rate) / win_rate))
                      else:
                          uv_losses = max(1, existing_uv_wins * 100)
              except Exception as e:
                  print(f"Could not extract loss counts: {e}")
          
          # Add current run results to loss counts
          omnipkg_losses += (1 if omnipkg_conflict == 'FAIL' else 0)
          pip_losses += (1 if pip_conflict == 'FAIL' else 0)
          uv_losses += (1 if uv_conflict == 'FAIL' else 0)

          def calculate_win_rate(wins, losses):
              total = wins + losses
              return f"{(wins / total * 100):.0f}%" if total > 0 else "0%"

          omnipkg_wr = calculate_win_rate(omnipkg_wins, omnipkg_losses)
          pip_wr = calculate_win_rate(pip_wins, pip_losses)
          uv_wr = calculate_win_rate(uv_wins, uv_losses)

          print(f"Updated stats: omnipkg={omnipkg_wins}W/{omnipkg_losses}L/{omnipkg_saves}S, pip={pip_wins}W/{pip_losses}L, uv={uv_wins}W/{uv_losses}L")

          # Build the content using string concatenation to avoid f-string issues
          battle_stats_section_content = "## 🥊 omnipkg vs The World: Battle Statistics\n"
          battle_stats_section_content += "*Live-updated results from our continuous integration tests.*\n\n"
          battle_stats_section_content += "| Package Manager | Conflict Test Wins | Environment Saves | Result |\n"
          battle_stats_section_content += "|:----------------|:------------------:|:-------------------:|:-------|\n"
          battle_stats_section_content += f"| **omnipkg 🚀**  | **{omnipkg_wins}** ({omnipkg_wr} Win Rate) | **{omnipkg_saves}** | ✅ **Solves Conflicts & Heals Environment** |\n"
          battle_stats_section_content += f"| **pip 💥**      | {pip_wins} ({pip_wr} Win Rate) | 0 | ❌ Overwrites Packages |\n"
          battle_stats_section_content += f"| **uv ⚡️**      | {uv_wins} ({uv_wr} Win Rate) | 0 | ❌ Overwrites Packages |\n\n"
          battle_stats_section_content += "**Test Scenarios:**\n"
          battle_stats_section_content += "- **Conflict Test**: Attempting to install conflicting versions of another package manager (e.g., `pip==24.0` and `pip==23.2.1`). A \"Win\" means both versions are usable.\n"
          battle_stats_section_content += "- **Environment Save**: After another tool (`uv`) damages the environment by downgrading itself, `omnipkg revert` is run. A \"Save\" means the environment was successfully restored.\n\n"
          battle_stats_section_content += "### 📊 Recent Test Log\n"
          battle_stats_section_content += "| Date (UTC) | omnipkg (Conflict) | pip (Conflict) | uv (Conflict) | omnipkg (Revert) |\n"
          battle_stats_section_content += "|:-----------|:------------------:|:--------------:|:-------------:|:----------------:|\n"
          battle_stats_section_content += f"| {test_timestamp} | {omnipkg_conflict} | {pip_conflict} | {uv_conflict} | {omnipkg_revert} |"

          # Try to preserve some recent test history from existing README
          if README_FILE.exists():
              try:
                  readme_content = README_FILE.read_text(encoding='utf-8')
                  # Find existing test log entries (skip the header)
                  log_match = re.search(r'\| Date \(UTC\).*?\n\|:.*?\n((?:\| [^|]+.*?\n)*)', readme_content, re.MULTILINE)
                  if log_match:
                      existing_entries = log_match.group(1).strip().split('\n')
                      # Keep up to 4 most recent entries (plus our new one = 5 total)
                      for entry in existing_entries[:4]:
                          if entry.strip():
                              battle_stats_section_content += "\n" + entry
              except Exception as e:
                  print(f"Could not preserve test history: {e}")

          # --- UPDATE THE README FILE ---
          try:
              readme_content = README_FILE.read_text(encoding='utf-8') if README_FILE.exists() else "# omnipkg\n\n"
              start_marker, end_marker = "<!-- BATTLE_STATS_START -->", "<!-- BATTLE_STATS_END -->"

              if start_marker in readme_content and end_marker in readme_content:
                  before, after = readme_content.split(start_marker)[0], readme_content.split(end_marker)[1]
                  README_FILE.write_text(before + start_marker + "\n" + battle_stats_section_content + "\n" + end_marker + after, encoding='utf-8')
                  print("✅ README.md updated with accumulated battle stats")
              else:
                  updated_content = readme_content.rstrip() + "\n\n" + start_marker + "\n" + battle_stats_section_content + "\n" + end_marker + "\n"
                  README_FILE.write_text(updated_content, encoding='utf-8')
                  print("✅ README.md updated (markers added automatically)")
          except Exception as e:
              print(f"Error updating README: {e}")
          EOF
          python update_battle_report.py

      - name: 💾 Commit README Updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "omnipkg Battle Bot"
          
          # Pull latest changes first, before staging anything
          git pull --rebase origin main || true
          
          # Now stage and commit our changes
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "🥊 Battle update: omnipkg vs The World results"
            git push
          fi
