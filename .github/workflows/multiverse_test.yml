#!/usr/bin/env python3
"""
OMNIPKG MULTIVERSE ANALYSIS TEST - FIXED VERSION
================================================================================
This test validates that omnipkg can successfully manage multiple Python versions
and perform cross-dimensional package operations.

Key improvements:
- Adopts both Python versions before testing
- Better error handling and recovery
- More robust version detection
- Cleaner output formatting
================================================================================
"""

import subprocess
import sys
import json
import re
from pathlib import Path
from typing import Optional, Dict, List, Tuple


def run_command(cmd: str, timeout: int = 300, check_exit_code: bool = True) -> Tuple[int, str]:
    """Run a shell command and return exit code and output."""
    print(f"â–¶ï¸  Executing: {cmd}")
    print(f"   Command: {cmd}")
    print("   --- Live Output ---")
    
    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        # Print output with proper formatting
        if result.stdout:
            for line in result.stdout.strip().split('\n'):
                print(f"   | {line}")
        if result.stderr:
            for line in result.stderr.strip().split('\n'):
                print(f"   | ERROR: {line}")
        
        print("   -------------------")
        print(f"   âœ… Command finished with exit code: {result.returncode}")
        
        if check_exit_code and result.returncode != 0:
            raise RuntimeError(f"Command failed with exit code {result.returncode}")
            
        return result.returncode, result.stdout + result.stderr
        
    except subprocess.TimeoutExpired:
        print(f"   âŒ Command timed out after {timeout} seconds")
        if check_exit_code:
            raise RuntimeError(f"Command timed out: {cmd}")
        return -1, "Command timed out"
    except Exception as e:
        print(f"   âŒ Command failed: {e}")
        if check_exit_code:
            raise
        return -1, str(e)


def get_current_python_version() -> str:
    """Get the current Python version."""
    version_info = sys.version_info
    return f"{version_info.major}.{version_info.minor}"


def adopt_python_version(version: str) -> bool:
    """Adopt a Python version into omnipkg management."""
    print(f"ğŸ Adopting Python {version} into omnipkg management...")
    
    try:
        exit_code, output = run_command(f"omnipkg python adopt {version}")
        
        # Check for success indicators
        success_indicators = [
            "New interpreter bootstrapped",
            "Omnipkg bootstrapped successfully",
            "already adopted",
            "successfully adopted"
        ]
        
        return any(indicator in output for indicator in success_indicators)
        
    except Exception as e:
        print(f"âŒ Failed to adopt Python {version}: {e}")
        return False


def list_managed_interpreters() -> Dict[str, str]:
    """Get a list of managed Python interpreters."""
    print("ğŸ“‹ Listing managed Python interpreters...")
    
    try:
        exit_code, output = run_command("omnipkg python list", check_exit_code=False)
        
        interpreters = {}
        
        # Parse the output to extract version info
        for line in output.split('\n'):
            # Look for version patterns like "Python 3.9:" or "3.9:"
            match = re.search(r'(\d+\.\d+).*?(/[^\s]+)', line)
            if match:
                version, path = match.groups()
                interpreters[version] = path
        
        print(f"   Found {len(interpreters)} managed interpreters: {list(interpreters.keys())}")
        return interpreters
        
    except Exception as e:
        print(f"âŒ Failed to list interpreters: {e}")
        return {}


def switch_python_context(version: str) -> bool:
    """Switch to a specific Python version context."""
    print(f"ğŸ”„ Switching to Python {version} context...")
    
    try:
        exit_code, output = run_command(f"omnipkg swap python {version}")
        
        success_indicators = [
            f"Successfully switched omnipkg context to Python {version}",
            f"switched to Python {version}",
            "Just kidding, omnipkg handled it for you automatically"
        ]
        
        return any(indicator in output for indicator in success_indicators)
        
    except Exception as e:
        print(f"âŒ Failed to switch to Python {version}: {e}")
        return False


def verify_python_context(expected_version: str) -> bool:
    """Verify we're in the expected Python context."""
    print(f"ğŸ” Verifying Python {expected_version} context...")
    
    try:
        exit_code, output = run_command("python --version")
        
        # Extract version from output like "Python 3.9.23"
        match = re.search(r'Python (\d+\.\d+)', output)
        if match:
            actual_version = match.group(1)
            if actual_version == expected_version:
                print(f"   âœ… Confirmed Python {actual_version} context")
                return True
            else:
                print(f"   âŒ Expected Python {expected_version}, but got Python {actual_version}")
                return False
        else:
            print(f"   âŒ Could not parse Python version from: {output}")
            return False
            
    except Exception as e:
        print(f"âŒ Failed to verify Python context: {e}")
        return False


def test_package_operation(version: str, package: str = "requests") -> bool:
    """Test a simple package operation in the given Python context."""
    print(f"ğŸ“¦ Testing package operation with Python {version}...")
    
    try:
        # Try to show package info (lightweight test)
        exit_code, output = run_command(f"python -c \"import sys; print(f'Python {{sys.version_info.major}}.{{sys.version_info.minor}} is working')\"")
        
        if f"Python {version} is working" in output:
            print(f"   âœ… Python {version} context is working correctly")
            return True
        else:
            print(f"   âŒ Python {version} context test failed")
            return False
            
    except Exception as e:
        print(f"âŒ Package operation test failed: {e}")
        return False


def multiverse_analysis() -> bool:
    """
    Main multiverse analysis test function.
    
    This test:
    1. Identifies the current Python version
    2. Adopts both Python 3.11 and 3.9 into omnipkg
    3. Tests switching between contexts
    4. Verifies each context works correctly
    5. Returns to the original context
    """
    
    print("=" * 80)
    print("  ğŸš€ OMNIPKG MULTIVERSE ANALYSIS TEST - FIXED VERSION")
    print("=" * 80)
    
    # Step 1: Identify current Python version
    current_version = get_current_python_version()
    print(f"ğŸ” Current Python version: {current_version}")
    
    # Step 2: Adopt current Python version first
    print(f"\nğŸ“¦ STEP 1: Adopting current Python {current_version}...")
    if not adopt_python_version(current_version):
        print(f"âŒ Failed to adopt current Python {current_version}")
        return False
    
    # Step 3: Adopt Python 3.9 if not current version
    target_version = "3.9"
    if current_version != target_version:
        print(f"\nğŸ“¦ STEP 2: Adopting Python {target_version}...")
        if not adopt_python_version(target_version):
            print(f"âŒ Failed to adopt Python {target_version}")
            return False
    
    # Step 4: List managed interpreters
    print(f"\nğŸ“‹ STEP 3: Verifying managed interpreters...")
    interpreters = list_managed_interpreters()
    
    required_versions = {current_version}
    if target_version != current_version:
        required_versions.add(target_version)
    
    for version in required_versions:
        if version not in interpreters:
            print(f"âŒ Python {version} is not in managed interpreters")
            return False
    
    print("âœ… All required Python versions are managed by omnipkg")
    
    # Step 5: Test context switching and operations
    test_results = []
    
    for test_version in required_versions:
        print(f"\nğŸ§ª STEP 4.{len(test_results)+1}: Testing Python {test_version} dimension...")
        
        # Switch to this version
        if not switch_python_context(test_version):
            print(f"âŒ Failed to switch to Python {test_version}")
            test_results.append(False)
            continue
        
        # Verify the context
        if not verify_python_context(test_version):
            print(f"âŒ Python {test_version} context verification failed")
            test_results.append(False)
            continue
        
        # Test basic operations
        if not test_package_operation(test_version):
            print(f"âŒ Python {test_version} operations test failed")
            test_results.append(False)
            continue
        
        print(f"âœ… Python {test_version} dimension test passed")
        test_results.append(True)
    
    # Step 6: Return to original context
    print(f"\nğŸ”„ STEP 5: Returning to original Python {current_version} context...")
    if not switch_python_context(current_version):
        print(f"âš ï¸  Warning: Failed to return to original Python {current_version} context")
        # Don't fail the test for this - it's a cleanup step
    else:
        print(f"âœ… Successfully returned to Python {current_version} context")
    
    # Final verification
    if not verify_python_context(current_version):
        print(f"âš ï¸  Warning: Final context verification failed")
    
    # Summary
    print(f"\n" + "=" * 80)
    print("  ğŸ“Š MULTIVERSE ANALYSIS RESULTS")
    print("=" * 80)
    
    success_count = sum(test_results)
    total_count = len(test_results)
    
    print(f"âœ… Successful dimension tests: {success_count}/{total_count}")
    
    if all(test_results):
        print("ğŸ‰ MULTIVERSE ANALYSIS PASSED: All Python dimensions are operational!")
        return True
    else:
        print("âŒ MULTIVERSE ANALYSIS FAILED: Some dimensions are not operational")
        return False


if __name__ == "__main__":
    try:
        success = multiverse_analysis()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Test interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n\nğŸ’¥ Test crashed with unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
