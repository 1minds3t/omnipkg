name: Auto-merge Development to Main

on:
  workflow_run:
    workflows:
      - "Cross-Platform Sanity Check"
      - "Package Discovery Demo - Omnipkg Intelligence"
      - "LIVE - Quantum Python Auto-Switch Test"
      - "Flask Port Finder & Auto-Healing Test"
      - "Live NumPy/SciPy Hot-Swapping"
      - "LIVE - Python Library Hot-Swap"
      - "Nuclear Test: TensorFlow Dependency Hot-Swap"
      - "LIVE - Package Upgrade Test"
      - "LIVE - Omnipkg Self-Upgrade Test"
      - "Omnipkg Multi-Language Intelligence Demo"
      - "LIVE - Omnipkg Quantum Multiverse Warp (FINAL)"
      - "Package Manager Comparison Test"
      - "macOS - Omnipkg Demo Test (CI - No Redis)"
      - "Windows - Omnipkg Demo Test (CI - No Redis)"
      - "Omnipkg True First-Run Test (Windows)"
      - "UV Self-Downgrades Auto-Revert"
      - "Simple UV Multi-Version Test"
      - "Old Rich Test"
      - "Simple Python Adoption Test"
      - "Demo Matrix Test (All Demos)"
    types:
      - completed
    branches:
      - development

permissions:
  contents: write
  actions: read

concurrency:
  group: auto-merge-main
  cancel-in-progress: false

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'development'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Check Clean Commit History
      id: check
      run: |
        COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
        SHORT_SHA=$(echo $COMMIT_SHA | cut -c1-7)
        
        echo "Checking commit $SHORT_SHA"
        
        # Get the last commit that's in main
        git fetch origin main
        LAST_MAIN_COMMIT=$(git rev-parse origin/main)
        
        echo "Last commit in main: $(echo $LAST_MAIN_COMMIT | cut -c1-7)"
        
        # Get all commits between main and this commit
        COMMITS_BETWEEN=$(git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA --count)
        
        echo "Commits between main and current: $COMMITS_BETWEEN"
        
        # If only 1 commit, check if all its workflows passed
        if [ "$COMMITS_BETWEEN" -eq 1 ]; then
          echo "Single commit - checking if all workflows passed"
          
          gh run list \
            --branch development \
            --commit $COMMIT_SHA \
            --json conclusion,status \
            --limit 100 > runs.json
          
          TOTAL=$(jq 'length' runs.json)
          SUCCESS=$(jq '[.[] | select(.conclusion == "success" or .conclusion == "skipped")] | length' runs.json)
          IN_PROGRESS=$(jq '[.[] | select(.status == "in_progress" or .status == "queued")] | length' runs.json)
          FAILED=$(jq '[.[] | select(.conclusion == "failure")] | length' runs.json)
          
          echo "Workflows: Total=$TOTAL, Success=$SUCCESS, InProgress=$IN_PROGRESS, Failed=$FAILED"
          
          if [ "$IN_PROGRESS" -gt 0 ]; then
            echo "Workflows still running"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_pending" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "Some workflows failed"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_failed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$SUCCESS" -lt 5 ]; then
            echo "Not enough workflows"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=not_enough_workflows" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Single clean commit, all workflows passed - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Multiple commits - check if ALL of them passed CI
        echo "Multiple commits ($COMMITS_BETWEEN) - checking for clean streak"
        
        # Get list of all commits
        git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA > commits.txt
        
        ALL_CLEAN=true
        
        while read commit; do
          commit_short=$(echo $commit | cut -c1-7)
          echo "Checking commit $commit_short"
          
          # Check if this commit has any failed workflows
          gh run list \
            --branch development \
            --commit $commit \
            --json conclusion \
            --limit 100 > commit_runs.json
          
          FAILED_COUNT=$(jq '[.[] | select(.conclusion == "failure")] | length' commit_runs.json)
          
          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "Commit $commit_short had $FAILED_COUNT failed workflows"
            ALL_CLEAN=false
            break
          fi
        done < commits.txt
        
        if [ "$ALL_CLEAN" = true ]; then
          echo "All $COMMITS_BETWEEN commits have clean CI - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_BETWEEN" >> $GITHUB_OUTPUT
        else
          echo "Found failed commits in history - manual merge required"
          echo "should_merge=false" >> $GITHUB_OUTPUT
          echo "reason=failed_commits_in_history" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check Not Already Merged
      if: steps.check.outputs.should_merge == 'true'
      id: check_merged
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        git fetch origin main
        
        if git merge-base --is-ancestor $COMMIT_SHA origin/main; then
          echo "already_merged=true" >> $GITHUB_OUTPUT
        else
          echo "already_merged=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Merge to Main
      if: steps.check.outputs.should_merge == 'true' && steps.check_merged.outputs.already_merged == 'false'
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.check.outputs.short_sha }}"
        COMMIT_COUNT="${{ steps.check.outputs.commit_count }}"
        
        git checkout main
        git pull origin main
        git fetch origin development
        
        if [ -n "$COMMIT_COUNT" ] && [ "$COMMIT_COUNT" -gt 1 ]; then
          MESSAGE="Auto-merge: $COMMIT_COUNT clean commits from development ($SHORT_SHA)"
        else
          MESSAGE="Auto-merge: development to main ($SHORT_SHA)"
        fi
        
        git merge $COMMIT_SHA --no-ff -m "$MESSAGE" -m "All CI checks passed"
        git push origin main
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
