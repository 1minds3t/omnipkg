name: Auto-merge Development to Main

on:
  workflow_run:
    workflows:
      - "Cross-Platform Sanity Check"
      - "Package Discovery Demo - Omnipkg Intelligence"
      - "LIVE - Quantum Python Auto-Switch Test"
      - "Flask Port Finder & Auto-Healing Test"
      - "Live NumPy/SciPy Hot-Swapping"
      - "LIVE - Python Library Hot-Swap"
      - "Nuclear Test: TensorFlow Dependency Hot-Swap"
      - "LIVE - Package Upgrade Test"
      - "LIVE - Omnipkg Self-Upgrade Test"
      - "Omnipkg Multi-Language Intelligence Demo"
      - "LIVE - Omnipkg Quantum Multiverse Warp (FINAL)"
      - "Package Manager Comparison Test"
      - "macOS - Omnipkg Demo Test (CI - No Redis)"
      - "Windows - Omnipkg Demo Test (CI - No Redis)"
      - "Omnipkg True First-Run Test (Windows)"
      - "UV Self-Downgrades Auto-Revert"
      - "Simple UV Multi-Version Test"
      - "Old Rich Test"
      - "Simple Python Adoption Test"
      - "Demo Matrix Test (All Demos)"
    types:
      - completed
    branches:
      - development
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Specific commit SHA to merge (leave empty for latest development)'
        required: false
        type: string

permissions:
  contents: write
  actions: read
  pull-requests: write

concurrency:
  group: auto-merge-main
  cancel-in-progress: false

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'development')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Determine Commit to Check
      id: get_commit
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger
          if [ -n "${{ inputs.commit_sha }}" ]; then
            COMMIT_SHA="${{ inputs.commit_sha }}"
            echo "Using manually specified commit: $COMMIT_SHA"
          else
            # Get latest commit from development
            git fetch origin development
            COMMIT_SHA=$(git rev-parse origin/development)
            echo "Using latest development commit: $COMMIT_SHA"
          fi
        else
          # Automatic trigger from workflow_run
          COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
          echo "Using commit from workflow_run: $COMMIT_SHA"
        fi
        
        echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
        echo "short_sha=$(echo $COMMIT_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
    
    - name: Check Clean Commit History
      id: check
      run: |
        COMMIT_SHA="${{ steps.get_commit.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.get_commit.outputs.short_sha }}"
        
        echo "Checking commit $SHORT_SHA"
        
        # Get the last commit that's in main
        git fetch origin main
        LAST_MAIN_COMMIT=$(git rev-parse origin/main)
        
        echo "Last commit in main: $(echo $LAST_MAIN_COMMIT | cut -c1-7)"
        
        # Get all commits between main and this commit
        COMMITS_BETWEEN=$(git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA --count)
        
        echo "Commits between main and current: $COMMITS_BETWEEN"
        
        # If only 1 commit, check if all its workflows passed
        if [ "$COMMITS_BETWEEN" -eq 1 ]; then
          echo "Single commit - checking if all workflows passed"
          
          gh run list \
            --branch development \
            --commit $COMMIT_SHA \
            --json conclusion,status \
            --limit 100 > runs.json
          
          TOTAL=$(jq 'length' runs.json)
          SUCCESS=$(jq '[.[] | select(.conclusion == "success" or .conclusion == "skipped")] | length' runs.json)
          IN_PROGRESS=$(jq '[.[] | select(.status == "in_progress" or .status == "queued")] | length' runs.json)
          FAILED=$(jq '[.[] | select(.conclusion == "failure")] | length' runs.json)
          
          echo "Workflows: Total=$TOTAL, Success=$SUCCESS, InProgress=$IN_PROGRESS, Failed=$FAILED"
          
          if [ "$IN_PROGRESS" -gt 0 ]; then
            echo "Workflows still running"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_pending" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "Some workflows failed"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_failed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$SUCCESS" -lt 5 ]; then
            echo "Not enough workflows"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=not_enough_workflows" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Single clean commit, all workflows passed - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=auto" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Multiple commits - check if ALL of them passed CI
        echo "Multiple commits ($COMMITS_BETWEEN) - checking for clean streak"
        
        # Get list of all commits
        git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA > commits.txt
        
        ALL_CLEAN=true
        FAILED_COMMITS=""
        
        while read commit; do
          commit_short=$(echo $commit | cut -c1-7)
          echo "Checking commit $commit_short"
          
          # Check if this commit has any failed workflows
          gh run list \
            --branch development \
            --commit $commit \
            --json conclusion \
            --limit 100 > commit_runs.json
          
          FAILED_COUNT=$(jq '[.[] | select(.conclusion == "failure")] | length' commit_runs.json)
          
          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "Commit $commit_short had $FAILED_COUNT failed workflows"
            ALL_CLEAN=false
            FAILED_COMMITS="$FAILED_COMMITS $commit_short"
          fi
        done < commits.txt
        
        if [ "$ALL_CLEAN" = true ]; then
          echo "All $COMMITS_BETWEEN commits have clean CI - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=auto" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_BETWEEN" >> $GITHUB_OUTPUT
        else
          echo "Found failed commits in history - preparing for manual merge"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=manual" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_BETWEEN" >> $GITHUB_OUTPUT
          echo "failed_commits=$FAILED_COMMITS" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check Not Already Merged
      if: steps.check.outputs.should_merge == 'true'
      id: check_merged
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        git fetch origin main
        
        if git merge-base --is-ancestor $COMMIT_SHA origin/main; then
          echo "already_merged=true" >> $GITHUB_OUTPUT
        else
          echo "already_merged=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Auto-Merge to Main
      if: |
        steps.check.outputs.should_merge == 'true' && 
        steps.check_merged.outputs.already_merged == 'false' &&
        steps.check.outputs.merge_type == 'auto'
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.check.outputs.short_sha }}"
        COMMIT_COUNT="${{ steps.check.outputs.commit_count }}"
        
        git checkout main
        git pull origin main
        git fetch origin development
        
        if [ -n "$COMMIT_COUNT" ] && [ "$COMMIT_COUNT" -gt 1 ]; then
          MESSAGE="Auto-merge: $COMMIT_COUNT clean commits from development ($SHORT_SHA)"
        else
          MESSAGE="Auto-merge: development to main ($SHORT_SHA)"
        fi
        
        git merge $COMMIT_SHA --no-ff -m "$MESSAGE" -m "All CI checks passed"
        git push origin main
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Prepare Manual Merge PR
      if: |
        steps.check.outputs.should_merge == 'true' && 
        steps.check_merged.outputs.already_merged == 'false' &&
        steps.check.outputs.merge_type == 'manual'
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.check.outputs.short_sha }}"
        COMMIT_COUNT="${{ steps.check.outputs.commit_count }}"
        FAILED_COMMITS="${{ steps.check.outputs.failed_commits }}"
        
        # Create a unique branch name for this merge preparation
        MERGE_BRANCH="auto-merge/main-from-dev-$SHORT_SHA"
        
        git fetch origin main development
        
        # First, try to rebase development onto main to bring in any new changes
        echo "Attempting to rebase development onto main..."
        git checkout -b $MERGE_BRANCH origin/development
        
        # Try the rebase
        if git rebase origin/main; then
          echo "âœ… Rebase successful - no conflicts with main's latest changes"
          echo "REBASE_SUCCESS=true" >> $GITHUB_ENV
          
          # Push the rebased branch
          git push -f origin $MERGE_BRANCH
          
          # Now checkout main and prepare the merge
          git checkout main
          git pull origin main
          git checkout $MERGE_BRANCH
          
        else
          echo "âŒ Rebase conflicts detected - manual intervention required"
          echo "REBASE_SUCCESS=false" >> $GITHUB_ENV
          
          # Abort the rebase
          git rebase --abort
          
          # Get conflict info
          git checkout main
          git pull origin main
          git checkout -b $MERGE_BRANCH-conflict-check origin/development
          git rebase origin/main || true
          CONFLICT_FILES=$(git diff --name-only --diff-filter=U | tr '\n' ', ' | sed 's/,$//')
          git rebase --abort
          
          echo "CONFLICT_FILES=$CONFLICT_FILES" >> $GITHUB_ENV
          
          # Create notification issue instead of PR
          cat > conflict_notice.md << 'EOFNOTICE'
        ## ðŸ›‘ Rebase Conflicts Detected - Manual Merge Required
        
        Attempted to prepare an automatic merge from development to main, but conflicts were detected during rebase.
        
        ### Summary
        - **Commits to merge**: $COMMIT_COUNT
        - **Development HEAD**: `$SHORT_SHA`
        - **Failed commits in history**: $FAILED_COMMITS
        - **Conflicting files**: $CONFLICT_FILES
        
        ### What This Means
        The `main` branch has changes that conflict with development. Automatic merge preparation cannot proceed.
        
        ### Manual Steps Required
        ```bash
        git checkout development
        git pull
        git checkout main
        git pull
        git checkout -b manual-merge-$SHORT_SHA
        git merge development --no-ff
        # Resolve conflicts
        git commit
        git push origin manual-merge-$SHORT_SHA
        # Create PR manually
        ```
        
        Or use rebase:
        ```bash
        git checkout development
        git pull
        git rebase main
        # Resolve conflicts
        git rebase --continue
        git push -f origin development
        ```
        EOFNOTICE
          
          sed -i "s/\$COMMIT_COUNT/$COMMIT_COUNT/g" conflict_notice.md
          sed -i "s/\$SHORT_SHA/$SHORT_SHA/g" conflict_notice.md
          sed -i "s/\$FAILED_COMMITS/$FAILED_COMMITS/g" conflict_notice.md
          sed -i "s/\$CONFLICT_FILES/$CONFLICT_FILES/g" conflict_notice.md
          
          gh issue create \
            --title "ðŸ›‘ Manual Merge Required: Rebase Conflicts ($SHORT_SHA)" \
            --body-file conflict_notice.md \
            --label "merge-conflict" \
            --label "requires-manual-action"
          
          echo "Issue created to notify about rebase conflicts"
          exit 0
        fi
        
        # If we get here, rebase was successful - now prepare the merge
        git checkout main
        git pull origin main
        
        # Perform the merge but don't commit yet
        git merge $MERGE_BRANCH --no-commit --no-ff || true
        
        # Check if there are merge conflicts (shouldn't happen after successful rebase, but check anyway)
        if git diff --name-only --diff-filter=U | grep -q .; then
          echo "MERGE_CONFLICTS=true" >> $GITHUB_ENV
          MERGE_CONFLICT_FILES=$(git diff --name-only --diff-filter=U | tr '\n' ', ')
          echo "MERGE_CONFLICT_FILES=$MERGE_CONFLICT_FILES" >> $GITHUB_ENV
        else
          echo "MERGE_CONFLICTS=false" >> $GITHUB_ENV
          # Stage all changes
          git add -A
        fi
        
        # Push the merge branch
        git push -f origin $MERGE_BRANCH
        
        # Create PR body
        cat > pr_body.md << 'EOF'
        ## âš ï¸ Manual Review Required
        
        This merge was prepared automatically but requires manual review due to failed commits in the history.
        
        ### Summary
        - **Commits to merge**: $COMMIT_COUNT
        - **Development HEAD**: `$SHORT_SHA`
        - **Failed commits detected**: $FAILED_COMMITS
        - **Rebase status**: âœ… Successfully rebased onto main (no conflicts with latest changes)
        
        ### Instructions
        1. Review the changes in this PR
        2. Check the failed commits and ensure issues are resolved
        3. **Edit the merge commit message** to document what was fixed/changed
        4. Merge when ready
        
        ### Merge Status
        EOF
        
        if [ "$MERGE_CONFLICTS" = "true" ]; then
          echo "ðŸ”´ **Unexpected merge conflicts** in: $MERGE_CONFLICT_FILES" >> pr_body.md
          echo "" >> pr_body.md
          echo "Please resolve conflicts before merging (this shouldn't happen after successful rebase)." >> pr_body.md
        else
          echo "âœ… No conflicts - staged and ready to merge after review" >> pr_body.md
        fi
        
        # Substitute variables
        sed -i "s/\$COMMIT_COUNT/$COMMIT_COUNT/g" pr_body.md
        sed -i "s/\$SHORT_SHA/$SHORT_SHA/g" pr_body.md
        sed -i "s/\$FAILED_COMMITS/$FAILED_COMMITS/g" pr_body.md
        
        # Create or update PR
        gh pr create \
          --title "ðŸ”„ Merge development â†’ main ($SHORT_SHA) - Manual Review Required" \
          --body-file pr_body.md \
          --base main \
          --head $MERGE_BRANCH \
          --label "auto-merge-prepared" \
          --label "requires-review" || \
        gh pr edit $MERGE_BRANCH \
          --title "ðŸ”„ Merge development â†’ main ($SHORT_SHA) - Manual Review Required" \
          --body-file pr_body.md
        
        echo "Pull request created/updated for manual review"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
