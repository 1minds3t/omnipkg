name: Auto-merge Development to Main

on:
  workflow_run:
    workflows:
      - "Cross-Platform Sanity Check"
      - "Package Discovery Demo - Omnipkg Intelligence"
      - "LIVE - Quantum Python Auto-Switch Test"
      - "Flask Port Finder & Auto-Healing Test"
      - "Live NumPy/SciPy Hot-Swapping"
      - "LIVE - Python Library Hot-Swap"
      - "Nuclear Test: TensorFlow Dependency Hot-Swap"
      - "LIVE - Package Upgrade Test"
      - "LIVE - Omnipkg Self-Upgrade Test"
      - "Omnipkg Multi-Language Intelligence Demo"
      - "LIVE - Omnipkg Quantum Multiverse Warp (FINAL)"
      - "Package Manager Comparison Test"
      - "macOS - Omnipkg Demo Test (CI - No Redis)"
      - "Windows - Omnipkg Demo Test (CI - No Redis)"
      - "Omnipkg True First-Run Test (Windows)"
      - "UV Self-Downgrades Auto-Revert"
      - "Simple UV Multi-Version Test"
      - "Old Rich Test"
      - "Simple Python Adoption Test"
      - "Demo Matrix Test (All Demos)"
    types:
      - completed
    branches:
      - development
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Specific commit SHA to merge (leave empty for latest development)'
        required: false
        type: string

permissions:
  contents: write
  actions: read
  pull-requests: write

concurrency:
  group: auto-merge-main
  cancel-in-progress: false

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'development')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Determine Commit to Check
      id: get_commit
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger
          if [ -n "${{ inputs.commit_sha }}" ]; then
            COMMIT_SHA="${{ inputs.commit_sha }}"
            echo "Using manually specified commit: $COMMIT_SHA"
          else
            # Get latest commit from development
            git fetch origin development
            COMMIT_SHA=$(git rev-parse origin/development)
            echo "Using latest development commit: $COMMIT_SHA"
          fi
        else
          # Automatic trigger from workflow_run
          COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
          echo "Using commit from workflow_run: $COMMIT_SHA"
        fi
        
        echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
        echo "short_sha=$(echo $COMMIT_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
    
    - name: Check Clean Commit History
      id: check
      run: |
        COMMIT_SHA="${{ steps.get_commit.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.get_commit.outputs.short_sha }}"
        
        echo "Checking commit $SHORT_SHA"
        
        # Get the last commit that's in main
        git fetch origin main
        LAST_MAIN_COMMIT=$(git rev-parse origin/main)
        
        echo "Last commit in main: $(echo $LAST_MAIN_COMMIT | cut -c1-7)"
        
        # Get all commits between main and this commit
        COMMITS_BETWEEN=$(git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA --count)
        
        echo "Commits between main and current: $COMMITS_BETWEEN"
        
        # If only 1 commit, check if all its workflows passed
        if [ "$COMMITS_BETWEEN" -eq 1 ]; then
          echo "Single commit - checking if all workflows passed"
          
          gh run list \
            --branch development \
            --commit $COMMIT_SHA \
            --json conclusion,status \
            --limit 100 > runs.json
          
          TOTAL=$(jq 'length' runs.json)
          SUCCESS=$(jq '[.[] | select(.conclusion == "success" or .conclusion == "skipped")] | length' runs.json)
          IN_PROGRESS=$(jq '[.[] | select(.status == "in_progress" or .status == "queued")] | length' runs.json)
          FAILED=$(jq '[.[] | select(.conclusion == "failure")] | length' runs.json)
          
          echo "Workflows: Total=$TOTAL, Success=$SUCCESS, InProgress=$IN_PROGRESS, Failed=$FAILED"
          
          if [ "$IN_PROGRESS" -gt 0 ]; then
            echo "Workflows still running"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_pending" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "Some workflows failed"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=workflows_failed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$SUCCESS" -lt 5 ]; then
            echo "Not enough workflows"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            echo "reason=not_enough_workflows" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Single clean commit, all workflows passed - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=auto" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Multiple commits - check if ALL of them passed CI
        echo "Multiple commits ($COMMITS_BETWEEN) - checking for clean streak"
        
        # Get list of all commits
        git rev-list $LAST_MAIN_COMMIT..$COMMIT_SHA > commits.txt
        
        ALL_CLEAN=true
        FAILED_COMMITS=""
        
        while read commit; do
          commit_short=$(echo $commit | cut -c1-7)
          echo "Checking commit $commit_short"
          
          # Check if this commit has any failed workflows
          gh run list \
            --branch development \
            --commit $commit \
            --json conclusion \
            --limit 100 > commit_runs.json
          
          FAILED_COUNT=$(jq '[.[] | select(.conclusion == "failure")] | length' commit_runs.json)
          
          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "Commit $commit_short had $FAILED_COUNT failed workflows"
            ALL_CLEAN=false
            FAILED_COMMITS="$FAILED_COMMITS $commit_short"
          fi
        done < commits.txt
        
        if [ "$ALL_CLEAN" = true ]; then
          echo "All $COMMITS_BETWEEN commits have clean CI - auto-merge OK"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=auto" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_BETWEEN" >> $GITHUB_OUTPUT
        else
          echo "Found failed commits in history - preparing for manual merge"
          echo "should_merge=true" >> $GITHUB_OUTPUT
          echo "merge_type=manual" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_BETWEEN" >> $GITHUB_OUTPUT
          echo "failed_commits=$FAILED_COMMITS" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check Not Already Merged
      if: steps.check.outputs.should_merge == 'true'
      id: check_merged
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        git fetch origin main
        
        if git merge-base --is-ancestor $COMMIT_SHA origin/main; then
          echo "already_merged=true" >> $GITHUB_OUTPUT
        else
          echo "already_merged=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Auto-Merge to Main
      if: |
        steps.check.outputs.should_merge == 'true' && 
        steps.check_merged.outputs.already_merged == 'false' &&
        steps.check.outputs.merge_type == 'auto'
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.check.outputs.short_sha }}"
        COMMIT_COUNT="${{ steps.check.outputs.commit_count }}"
        
        git checkout main
        git pull origin main
        git fetch origin development
        
        if [ -n "$COMMIT_COUNT" ] && [ "$COMMIT_COUNT" -gt 1 ]; then
          MESSAGE="Auto-merge: $COMMIT_COUNT clean commits from development ($SHORT_SHA)"
        else
          MESSAGE="Auto-merge: development to main ($SHORT_SHA)"
        fi
        
        git merge $COMMIT_SHA --no-ff -m "$MESSAGE" -m "All CI checks passed"
        git push origin main
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Prepare Manual Merge PR
      if: |
        steps.check.outputs.should_merge == 'true' && 
        steps.check_merged.outputs.already_merged == 'false' &&
        steps.check.outputs.merge_type == 'manual'
      run: |
        COMMIT_SHA="${{ steps.check.outputs.commit_sha }}"
        SHORT_SHA="${{ steps.check.outputs.short_sha }}"
        COMMIT_COUNT="${{ steps.check.outputs.commit_count }}"
        FAILED_COMMITS="${{ steps.check.outputs.failed_commits }}"
        
        # Create a unique branch name for this merge preparation
        MERGE_BRANCH="auto-merge/main-from-dev-$SHORT_SHA"
        
        git fetch origin main development
        
        # Use merge strategy instead of rebase to avoid conflicts with historical edits
        echo "Preparing merge branch from main..."
        git checkout -b $MERGE_BRANCH origin/main
        
        # Try to merge development into this branch
        echo "Attempting to merge development..."
        if git merge origin/development --no-commit --no-ff; then
          echo "âœ… Merge successful - no conflicts"
          echo "MERGE_SUCCESS=true" >> $GITHUB_ENV
          echo "HAS_CONFLICTS=false" >> $GITHUB_ENV
          
          # Stage all changes
          git add -A
          
        else
          echo "âš ï¸ Merge conflicts detected"
          echo "MERGE_SUCCESS=true" >> $GITHUB_ENV
          echo "HAS_CONFLICTS=true" >> $GITHUB_ENV
          
          # Get list of conflicting files
          CONFLICT_FILES=$(git diff --name-only --diff-filter=U | tr '\n' ', ' | sed 's/,$//')
          echo "CONFLICT_FILES=$CONFLICT_FILES" >> $GITHUB_ENV
          
          # Check if it's ONLY the workflow file
          CONFLICT_COUNT=$(git diff --name-only --diff-filter=U | wc -l)
          WORKFLOW_CONFLICT=$(git diff --name-only --diff-filter=U | grep -c "auto-merge-to-main.yml" || echo "0")
          
          if [ "$CONFLICT_COUNT" -eq 1 ] && [ "$WORKFLOW_CONFLICT" -eq 1 ]; then
            echo "ðŸ¤– Only conflict is the workflow file itself - auto-resolving with development's version"
            git checkout --theirs .github/workflows/auto-merge-to-main.yml
            git add .github/workflows/auto-merge-to-main.yml
            echo "HAS_CONFLICTS=false" >> $GITHUB_ENV
            echo "AUTO_RESOLVED=true" >> $GITHUB_ENV
          fi
        fi
        
        # Push the merge branch
        git push -f origin $MERGE_BRANCH
        
        # Create PR body
        cat > pr_body.md << 'EOF'
        ## âš ï¸ Manual Review Required
        
        This merge was prepared automatically but requires manual review due to failed commits in the history.
        
        ### Summary
        - **Commits to merge**: $COMMIT_COUNT
        - **Development HEAD**: `$SHORT_SHA`
        - **Failed commits detected**: $FAILED_COMMITS
        - **Merge strategy**: Direct merge (not rebase)
        
        ### Instructions
        1. Review the changes in this PR
        2. Check the failed commits and ensure issues are resolved
        3. **Edit the merge commit message** to document what was fixed/changed
        4. Merge when ready
        
        ### Status
        EOF
        
        if [ "${AUTO_RESOLVED:-false}" = "true" ]; then
          echo "ðŸ¤– **Auto-resolved**: Workflow file conflict resolved automatically (kept development's version)" >> pr_body.md
          echo "" >> pr_body.md
        fi
        
        if [ "${HAS_CONFLICTS:-false}" = "true" ]; then
          echo "ðŸ”´ **Conflicts detected** in: $CONFLICT_FILES" >> pr_body.md
          echo "" >> pr_body.md
          echo "Please resolve conflicts before merging." >> pr_body.md
        else
          echo "âœ… No conflicts - staged and ready to merge after review" >> pr_body.md
        fi
        
        # Substitute variables
        sed -i "s/\$COMMIT_COUNT/$COMMIT_COUNT/g" pr_body.md
        sed -i "s/\$SHORT_SHA/$SHORT_SHA/g" pr_body.md
        sed -i "s/\$FAILED_COMMITS/$FAILED_COMMITS/g" pr_body.md
        
        # Create or update PR
        gh pr create \
          --title "ðŸ”„ Merge development â†’ main ($SHORT_SHA) - Manual Review Required" \
          --body-file pr_body.md \
          --base main \
          --head $MERGE_BRANCH \
          --label "auto-merge-prepared" \
          --label "requires-review" || \
        gh pr edit $MERGE_BRANCH \
          --title "ðŸ”„ Merge development â†’ main ($SHORT_SHA) - Manual Review Required" \
          --body-file pr_body.md
        
        echo "Pull request created/updated for manual review"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
